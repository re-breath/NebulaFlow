#rebreathçš„å‡½æ•°åº“
#ç¯å¢ƒå˜é‡éƒ¨åˆ†çš„å‡½æ•°
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

echo "#env setting"> ~/.rebreath/.config
source ~/.rebreath/.config
export PATH=$PATH:$HOME/.rebreath
alias loadenv='source ~/.bashrc'
alias modenv='vim ~/.bashrc'
alias py='python3'
export PYTHONPATH=$PYTHONPATH:$HOME/.rebreath/nebula_pylib
#module load compiler/gcc/12.2.0 2> /dev/null || true
alias modrenv='vim ~/.rebreath/rebreath-env-function'

while IFS= read -r -d '' file; do
    source "$file"
done < <(find ~/.rebreath/envsrc -type f -print0)


#å…³é—­vaspç»„ä»¶æœªä½¿ç”¨è­¦å‘Š
export OMPI_MCA_btl_base_warn_component_unused=0


#å¤„ç†æ•°æ®é›†æ•°æ®çš„å¿«æ·é”®ï¼Œå¯ä»¥ä½¿ç”¨æ¥å¤„ç†dumpæ–‡ä»¶çš„æ•°æ®
#ä¿®æ”¹æ˜¾ç¤ºçš„æ ·å¼
#PS1='\[\033[01;36m\]\uâ€”â€”>NebulaFlow:\W\[\033[01;32m\]$\[\033[01;34m\] '

loadrenv(){
#è¯¥å‡½æ•°ç”¨æ¥åŠ è½½NebulaFlowçš„ç¯å¢ƒå˜é‡
    source ~/.rebreath/rebreath-env-function
}

update_NebulaFlow(){
# è¯¥å‡½æ•°ä½¿ç”¨æ¥å¿«é€Ÿçš„æ›´æ–°NebulaFlowå‡½æ•°åº“
    local initAddress=$(pwd)
    echo "æ­£åœ¨æ›´æ–°NebulaFlow..."
    mkdir -p update_temp
    cd update_temp
    git clone https://github.com/re-breath/NebulaFlow.git 
    cd NebulaFlow
    bash NebulaFlowinstaller.sh
    cd $initAddress
    rm -rf update_temp
    echo "NebulaFlowæ›´æ–°å®Œæˆï¼"
}

use_agent(){
    export http_proxy="http://192.168.1.10:3128"
}

proxy_download() {
#è¯¥å‡½æ•°çš„ä½œç”¨ä¸ºä½¿ç”¨ä»£ç†èŠ‚ç‚¹ä¸‹è½½æ–‡ä»¶
    local remote_server="dhk@10.14.0.15" 
    local remote_path="/home/dhk/rebreath/proxy_downfiles" 
    local remote_temp_path="${remote_path}/temp" 

    # ç”¨sshåœ¨è¿œç¨‹æœåŠ¡å™¨çš„ä¸´æ—¶ç›®å½•åˆ›å»ºç›®å½•å¹¶ä¸‹è½½æ–‡ä»¶
    ssh -i ~/.ssh/id_rsa ${remote_server} "mkdir -p ${remote_temp_path} && cd ${remote_temp_path} && $1"
    
    # æ£€æŸ¥è¿œç¨‹ä¸‹è½½å‘½ä»¤çš„è¿”å›å€¼
    if [[ "$?" -ne 0 ]]; then
        echo "æ–‡ä»¶ä¸‹è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘½ä»¤å¹¶é‡è¯•ã€‚"
        return 1
    fi
    
    # ä½¿ç”¨scpä»ä¸´æ—¶æ–‡ä»¶å¤¹å¤åˆ¶æ‰€æœ‰æ–‡ä»¶åˆ°æœ¬åœ°å½“å‰ç›®å½•ä¸‹
    scp -rv -i ~/.ssh/id_rsa ${remote_server}:${remote_temp_path}/* .
    
    # æ£€æŸ¥scpå‘½ä»¤çš„è¿”å›å€¼
    if [[ "$?" -ne 0 ]]; then
        echo "æ–‡ä»¶å¤åˆ¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿œç¨‹æœåŠ¡å™¨ä¸Šçš„è·¯å¾„å’Œæ–‡ä»¶åã€‚"
        return 1
    fi

    # æ¸…ç©ºè¿œç¨‹æœåŠ¡å™¨ä¸­çš„ä¸´æ—¶ç›®å½•
    ssh -i ~/.ssh/id_rsa ${remote_server} "rm -rf ${remote_temp_path}/*"

    echo "æ–‡ä»¶å·²æˆåŠŸä¸‹è½½åˆ°æœ¬åœ°å¹¶æ¸…ç†äº†ä¸´æ—¶æ–‡ä»¶å¤¹ã€‚"
}


free_time_run() {
# ç›‘æµ‹åˆ°ç©ºé—²çš„gpuåè¿›è¡Œä»»åŠ¡
# ä½¿ç”¨æ¡ˆä¾‹ free_time_run 'nohup gpumd 2>&1 &'
  while true; do
    for gpu_id in $(nvidia-smi --query-gpu=index --format=csv,noheader,nounits); do
      mem_used=$(nvidia-smi --id=$gpu_id --query-gpu=memory.used --format=csv,noheader,nounits)
      if [ $mem_used -lt 200 ]; then
          export CUDA_VISIBLE_DEVICES=$gpu_id
          echo "Running task on GPU $gpu_id"
          eval $1
          break 2
      fi
      done
      echo "No free GPU found, waiting..."
      sleep 60
  done
  date '+%Y-%m-%d %H:%M:%S' >> run_train-file.log
  echo -e "æ‰§è¡Œ $1 \n" >> run_train-file.log    
}

search_large_files() {
# æœç´¢å½“å‰ç›®å½•ä¸‹æ‰€æœ‰å¤§äº20GBçš„æ–‡ä»¶
    find $1 -type f -size +20G
}
nohup_free_time_run(){
#è¯¥å‡½æ•°å°†ä»»åŠ¡æ”¾åˆ°åå°è¿è¡Œï¼Œå¹¶ç›‘æµ‹åˆ°ç©ºé—²çš„gpuåè¿›è¡Œä»»åŠ¡
#æ–°å¢åŠ çš„å‡½æ•°ï¼Œç­‰å¾…æ£€éªŒä¸­ï¼ˆï¼‰
    nohup free_time_run "$1" 2>&1 &
}

relib() {
# rebreathåº“çš„ç®¡ç†å‘˜   
#ç¤ºä¾‹ä½¿ç”¨æ–¹å¼ relib -v -m hp pre sh

    lib="$HOME/.rebreath"
    view=0
    multi=0
    args=()

    # å¤„ç†å‚æ•°
    while [ $# -gt 0 ]; do
        case "$1" in
            -v)
                view=1
                ;;
            -m)
                multi=1
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done

    # æ£€æŸ¥æ˜¯å¦æœ‰å®é™…çš„æŸ¥æ‰¾å…³é”®è¯
    if [ ${#args[@]} -eq 0 ]; then
        echo "è¯·æ³¨æ„æä¾›è‡³å°‘ä¸€ä¸ªæŸ¥æ‰¾å…³é”®è¯ã€‚"
        exit 521
    fi

    # ç”¨äºå­˜å‚¨ä¸­é—´ç»“æœçš„æ–‡ä»¶
    tmpfile=$(mktemp)

    # åˆå§‹æŸ¥æ‰¾
    find "$lib" -type f -name "*${args[0]}*" > "$tmpfile"

    # é€å±‚æ¬¡æŸ¥æ‰¾
    for keyword in "${args[@]:1}"; do
        new_tmpfile=$(mktemp)
        while IFS= read -r line; do
            find "$line" -type f -name "*$keyword*" >> "$new_tmpfile"
        done < "$tmpfile"
        mv "$new_tmpfile" "$tmpfile"
    done

    # æ‰§è¡ŒæŸ¥æ‰¾å’Œç›¸åº”æ“ä½œ
    if [ $view -eq 1 ]; then
        cat "$tmpfile"
    else
        while IFS= read -r line; do
            cp "$line" ./
        done < "$tmpfile"
    fi

    # ç§»é™¤ä¸´æ—¶æ–‡ä»¶
    rm -f "$tmpfile"
}


#+++++++++++++++++++++++++++æ–‡ä»¶æ“ä½œç›¸å…³å·¥å…·+++++++++++++++++++++++
recc(){
#åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„æ–‡ä»¶æ¥ä¿å­˜æŒ‡å®šæ–‡ä»¶çš„åœ°å€ï¼Œæ–¹ä¾¿åç»­å¯¹å…¶è¿›è¡Œæ“ä½œ
    local cc_tmpfile="/tmp/cc_fzmrkwjsbzz_pointer"
    for i in "$@"; do
        local fileaddress=$(realpath "$i")
        echo "$fileaddress" >> "$cc_tmpfile"
        echo "æ–‡ä»¶ $fileaddress å·²åŠ å…¥è®°å¿† â€¦â€¦"
    done
}

reclean(){
#æ¸…ç©ºè®°å¿†çš„ä¸´æ—¶æ–‡ä»¶
    local cc_tmpfile="/tmp/cc_fzmrkwjsbzz_pointer"
    if [ -f "$cc_tmpfile" ]; then
        > "$cc_tmpfile"
        echo "è®°å¿†å·²æ¸…ç©ºï¼"
    fi
}
recat(){
#æŸ¥çœ‹reccè®°å¿†çš„ä¸´æ—¶æ–‡ä»¶ä¸­çš„æ–‡ä»¶åœ°å€
    local cc_tmpfile="/tmp/cc_fzmrkwjsbzz_pointer"
    if [ -f "$cc_tmpfile" ]; then
        cat "$cc_tmpfile"
    else
        echo "ä¸´æ—¶æ–‡ä»¶ $cc_tmpfile ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œ recc å‘½ä»¤ã€‚"
    fi
}

revv(){
    # ç²˜è´´ä¹‹å‰çš„æ‰€æœ‰è®°å½•ä¸‹çš„æ–‡ä»¶ï¼Œå¹¶ä¸”å°†å…¶å¤åˆ¶åˆ°å½“å‰çš„æ–‡ä»¶å¤¹ä¸­
    local cc_tmpfile="/tmp/cc_fzmrkwjsbzz_pointer"
    local vv_dir=${1:-.}
    if [ -f "$cc_tmpfile" ]; then
        cat "$cc_tmpfile" | xargs -I {} cp -t "$vv_dir" {}
    else
        echo "ä¸´æ—¶æ–‡ä»¶ $cc_tmpfile ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œ recc å‘½ä»¤ã€‚"
    fi
}

function wslcd() {
#æ£€æŸ¥æ˜¯å¦æœ‰windowsè·¯å¾„ï¼Œå¦‚æœæœ‰å°±è½¬æ¢ä¸ºwsl-linuxè·¯å¾„
    local wsl_dir=$1
    if [[ $wsl_dir =~ ^([a-zA-Z]):(.*)$ ]]; then
        local drive=$(echo ${BASH_REMATCH[1]} | tr '[:upper:]' '[:lower:]')
        local path=${BASH_REMATCH[2]}
        path=$(echo $path | sed 's|\\|/|g')
        local wsl_path="/mnt/${drive}${path}"
        echo "è½¬æ¢åçš„wslè·¯å¾„ä¸ºï¼š$wsl_path"
        cd  -- "$wsl_path"
    else
        cd  -- "$wsl_dir"
    fi
}

winpath(){
#å°†windowsè·¯å¾„è½¬æ¢ä¸ºlinuxè·¯å¾„
    local wsl_dir=$1
    if [[ $wsl_dir =~ ^([a-zA-Z]):(.*)$ ]]; then
        local drive=$(echo ${BASH_REMATCH[1]} | tr '[:upper:]' '[:lower:]')
        local path=${BASH_REMATCH[2]}
        path=$(echo $path | sed 's|\\|/|g')
        local wsl_path="/mnt/${drive}${path}"
        echo "è½¬æ¢åçš„wslè·¯å¾„ä¸ºï¼š$wsl_path"
fi
}

#+++++++++++++++++++++++++++æ•°å­¦è®¡ç®—ç›¸å…³å·¥å…·++++++++++++++++++++++++++

pow(){
#è®¡ç®—å¹‚æ¬¡æ–¹
    local base=$1
    local exp=$2
    echo $((base**exp))
}

calc_time(){
#è®¡ç®—è¿è¡Œæ—¶é—´
    local start_time=$(date +%s%3N)
    eval "$@"
    local end_time=$(date +%s%3N)

    local time_diff=$((end_time-start_time))
    echo "è¿è¡Œæ—¶é—´ä¸ºï¼š $time_diff æ¯«ç§’"
}

echo "NebulaFlow library loaded" 'O.<'

#-----------------------------æ¨¡æ¿-----------------------------------


compute_high_of_tree() {
# åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶å¤¹æ¥ä¿å­˜ç”Ÿæˆçš„æ–‡ä»¶
    local tmpdir=$(mktemp -d -t high_of_tree-XXXXXX)
    
    # ä½¿ç”¨æŒ‡å®šçš„ä¸´æ—¶æ–‡ä»¶å¤¹
    pushd "$tmpdir"
    
    # ä½¿ç”¨shellè°ƒç”¨c++çš„æ¨¡æ¿
    cat > high_of_tree.cpp <<EOF
    #include <iostream>
    #include <cmath>
    #include <numbers>

    using namespace std;

    void high_of_tree(){
        const double pi  {std::numbers::pi};
        double high {};
        double h {};
        double d {};
        double angle {};
        cout << "è®¡ç®—æ ‘çš„é«˜åº¦" << endl;
        cout << "please enter h ,d ,angleï¼š";
        
        cin >> h >> d >> angle;
        cout << "h = " << h << "  d = " << d << "  angle = " << angle << endl;
        cout << "æ ‘çš„é«˜åº¦æ˜¯" << h + d * std::tan(angle * pi / 180) << endl;
    }

    int main(){
        high_of_tree();
        return 0;
    }
EOF

# ç¼–è¯‘C++ä»£ç 
g++ -std=c++20 high_of_tree.cpp -o high_of_tree

# è¿è¡Œç¨‹åº
./high_of_tree

# ä»ä¸´æ—¶æ–‡ä»¶å¤¹ä¸­è¿”å›åˆ°åŸå§‹ç›®å½•
popd

# åˆ é™¤ä¸´æ—¶æ–‡ä»¶å¤¹åŠå…¶å†…å®¹
rm -rf "$tmpdir"
}


#-----------------------------ç©å…·-----------------------------------------------

gpt9() {
    # å¼€å¯æ™ºèƒ½å¯¹è¯
    echo "hallo, æˆ‘æ˜¯gpt9, ä½ å¥½"
    while true; do
        echo -en "\e[33m$USER: \e[0m"
        read -r line
        case "$line" in
            exit|Exit|EXIT)
                echo "gpt9ï¼šå†è§ï¼"
                break
                ;;
            *)
                processed_line=$(echo "$line" | sed -e 's/å—//g; s/you//g; s/?/!/g; s/^ä½ /æˆ‘/g; s/æˆ‘/ä½ /g; s/å§//g; s/ï¼Ÿ/ï¼/g')
                echo -e "\e[32mgpt9ï¼š\e[0m $processed_line\n"
                ;;
        esac
    done
}

mycat(){
# Aiæ—¶ä»£,æ²¸è…¾æœŸå¾…
     echo "å–µå–µå–µ?(è¢«è¿«è¥ä¸šçš„å«å£°)"
     while true; do
         echo -en "\e[33m$USER: \e[0m"
         read -r line
         if [[ "$line" == "exit" ]]; then
             echo "(o^â€¥^)o mewï¼(ä¸èˆçš„å«å£°)"
             break
         fi

        emojis=('â—Ÿ[Ë³_Ë³]ÊŒË½ÊŒ' '(=â™¡ á†º â™¡=)' '=ï¼¾â€¢ â‹ â€¢ï¼¾=' 'Ì³ áŸ±Ë³_Ë³áŸ± Ì³ âˆ«' 'ï¼¾âŒ¤ï¼¾' '[^._.^]ï¾‰å½¡' '/á ï½¡êˆï½¡áŸ\' '/á ï½¡êˆï½¡áŸâœ¿\' 'âœ§/á -êˆ-áŸ\' '/á ğ…’ â€¸ ğ…’áŸ\ï¾‰' 'â€”à¸…/á . Ì« .áŸ\à¸… â€”' '/á _ êˆ _áŸ\É´Êá´€~' 'à¸…^â€¢ï»Œâ€¢^à¸…' '(à¸…^ï½¥Ï‰ï½¥^ à¸…)' '(Â´à¸…Ï‰â€¢à¸…ï½€)' '~(=^â€¥^)ï¾‰â—ï½')

        random_emoji=${emojis[$RANDOM % ${#emojis[@]} ]}
         random_number=$(shuf -i 1-4 -n 1)
         processed_line=$(printf "%0.så–µ" $(seq 1 $random_number))
         echo -e "\e[32m${random_emoji}ï¼š\e[0m $processed_line\n"
     done
}

dirman(){
# æŸ¥çœ‹ç›®å½•ä¸‹çš„æ‰‹å†Œ
# ä½¿ç”¨æ–¹æ³•ï¼šdirman /path/to/directory
    local path=$(realpath "$1")
    echo ""
    echo "â€”â€”>æŒ‡å®šç›®å½•ï¼š$path"
    cat $path/.dirlog
    echo 'Task completed. See you later! O.<'
    echo ""
}

wdlog(){
# è®°å½•ç›®å½•çš„æ“ä½œè®°å½•
    local init=$PWD
    local path=${1:-init}

    vim "$path/.dirlog"
}

addpath(){
# æ·»åŠ ç¯å¢ƒå˜é‡
    local path=$(realpath "$1")
    echo "export PATH=$path"':$PATH' >> ~/.bashrc
}

wc_file_lines() {
    # æŸ¥æ‰¾å½“å‰ç›®å½•åŠå…¶å­ç›®å½•ä¸‹çš„æ‰€æœ‰ åç¼€ä¸º$model_name çš„æ–‡ä»¶ï¼Œå¹¶ç»Ÿè®¡æ¯ä¸ªæ–‡ä»¶çš„è¡Œæ•°
    # ç„¶åæŒ‰è¡Œæ•°æ’åºå¹¶è¾“å‡ºå‰ä¸‰ä¸ªæ–‡ä»¶
    local model_name=$1
    find . -name "*.$model_name" -type f -exec wc -l {} + | sort -nr | head -n 6 | tail -n 5
    echo "Total lines in all .$model_name files:"
    find . -name "*.$model_name" -type f -exec wc -l {} + | tail -n 1 | awk '{print $1}'
}

